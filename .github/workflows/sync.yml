name: Auto Sync n8n-advanced with Upstream
on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:

permissions:
  contents: write
  actions: read

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_PAT }}
          
      - name: Configure Git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          
      - name: Sync with latest RELEASE (not master)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # --- RETRY LOOP 1: Get Version ---
          echo "Fetching Latest Release (5 attempts)..."
          for i in {1..5}; do
            LATEST_RELEASE=$(gh release view --repo n8n-io/n8n --json tagName --jq .tagName) && break
            echo "Error fetching version (Attempt $i). Waiting 10s..."
            sleep 10
          done

          if [ -z "$LATEST_RELEASE" ]; then
            echo "CRITICAL: Could not find release tag. Aborting."
            exit 1
          fi

          # --- CHECK IF REBUILD NEEDED ---
          # We only rebuild if:
          # 1. n8n released a new version we don't have yet OR
          # 2. We committed new code since our last release
          
          # Check if we already have a release with this tag name
          OUR_RELEASE=$(gh release view "$LATEST_RELEASE" --repo "$GITHUB_REPOSITORY" --json tagName --jq '.tagName' 2>/dev/null || echo "")
          
          if [ -z "$OUR_RELEASE" ]; then
            echo "New n8n release detected: $LATEST_RELEASE. Proceeding with sync..."
          else
            # We have the release - check if current HEAD matches the release
            # Get commit from tag (dereference to actual commit for annotated tags)
            TAG_INFO=$(gh api repos/$GITHUB_REPOSITORY/git/refs/tags/$LATEST_RELEASE 2>/dev/null || echo "")
            if [ -n "$TAG_INFO" ]; then
              TAG_TYPE=$(echo "$TAG_INFO" | jq -r '.object.type')
              if [ "$TAG_TYPE" = "tag" ]; then
                # Annotated tag - need to dereference
                TAG_SHA=$(echo "$TAG_INFO" | jq -r '.object.sha')
                RELEASE_COMMIT=$(gh api repos/$GITHUB_REPOSITORY/git/tags/$TAG_SHA --jq '.object.sha' 2>/dev/null || echo "none")
              else
                # Lightweight tag - direct commit
                RELEASE_COMMIT=$(echo "$TAG_INFO" | jq -r '.object.sha')
              fi
            else
              RELEASE_COMMIT="none"
            fi
            
            CURRENT_HEAD=$(git rev-parse HEAD)
            
            echo "Release commit: $RELEASE_COMMIT"
            echo "Current HEAD: $CURRENT_HEAD"
            
            if [ "$RELEASE_COMMIT" = "$CURRENT_HEAD" ]; then
              echo "Release $LATEST_RELEASE exists and matches current code. Nothing to do."
              exit 0
            else
              echo "Code changed since last release. Rebuilding..."
            fi
          fi
          # ------------------------------
          
          echo "Syncing with release: $LATEST_RELEASE"
          
          git remote add upstream https://github.com/n8n-io/n8n.git || true
          
          # --- RETRY LOOP 2: Git Fetch ---
          echo "Running git fetch (with retries)..."
          for i in {1..5}; do
            git fetch upstream --tags --force && break
            echo "Git fetch failed (Attempt $i). Waiting 10s..."
            sleep 10
          done
          
          # Try merge with -X ours. If it fails, resolve manually in loop.
          if ! git merge "$LATEST_RELEASE" --allow-unrelated-histories -X ours; then
            echo "Merge conflict detected. Starting manual resolution..."
            CONFLICTS=$(git diff --name-only --diff-filter=U)
            
            for file in $CONFLICTS; do
              echo "Resolving: $file"
              echo "   -> Taking OUR version (Ours)"
              if git ls-tree -r HEAD --name-only | grep -q "^$file$"; then
                # We have the file -> Keep our version
                git checkout --ours -- "$file"
                git add "$file"
              else
                # We deleted the file -> Keep it deleted
                git rm "$file"
              fi
            done
            
            if [ -n "$(git diff --name-only --diff-filter=U)" ]; then
              echo "ERROR: Unresolved conflicts remain."
              exit 1
            fi
            
            git commit -m "Merge release $LATEST_RELEASE (Automatic Conflict Resolution)"
          fi
          
          # --- WORKFLOW CLEANUP ---
          echo "Cleaning up upstream workflows..."
          
          # 1. Delete ALL workflows in the folder (removes n8n junk + our files temporarily)
          git rm -r --ignore-unmatch .github/workflows/
          
          # 2. Restore YOUR workflows from the original commit
          git checkout ${{ github.sha }} -- .github/workflows/
          
          git add .github/workflows/
          if ! git diff --cached --quiet; then
            git commit -m "Restore custom workflows from original state"
          fi
          # ------------------------

          # --- INJECT CUSTOM NODES ---
          echo "Injecting custom nodes into package.json..."
          
          # Make script executable just in case
          chmod +x .github/scripts/inject-custom-nodes.sh
          
          # Run the injection script
          bash .github/scripts/inject-custom-nodes.sh
          
          # Commit the injection
          git add packages/nodes-base/package.json
          if ! git diff --cached --quiet; then
             git commit -m "Inject Custom Nodes into package.json"
          fi
          # ---------------------------
          
          
          git remote set-url origin https://${{ secrets.GH_PAT }}@github.com/${{ github.repository }}.git
          
          # --- RETRY LOOP 3: Git Push ---
          for i in {1..5}; do
              git push origin master && break
              echo "Git push failed (Attempt $i). Waiting 15s..."
              sleep 15
          done
          
      - name: Create our Release
        env:
          GITHUB_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          # Fetch tag again to be safe
          LATEST_RELEASE=$(gh release view --repo n8n-io/n8n --json tagName --jq .tagName)

          # Delete old release with tag if it exists (allows rebuild with new code)
          gh release delete "$LATEST_RELEASE" --repo "$GITHUB_REPOSITORY" --cleanup-tag -y 2>/dev/null || true

          # Recreate tag on current HEAD
          git tag -f "$LATEST_RELEASE"
          git push origin "$LATEST_RELEASE" -f

          # Get latest commit info for release title/notes
          COMMIT_TITLE=$(git log -1 --pretty=%s)
          COMMIT_BODY=$(git log -1 --pretty=%b)
          
          # Read stardawn version
          STARDAWN_VERSION=$(cat STARDAWN_VERSION 2>/dev/null || echo "1.0")
          
          # Build release title with both versions
          RELEASE_TITLE="n8n-advanced Release $LATEST_RELEASE stardawn@$STARDAWN_VERSION"
          
          # Build release notes using printf (avoid heredoc YAML issues)
          RELEASE_NOTES=$(printf "## n8n-advanced Release %s stardawn@%s\n\n**n8n Base Version:** %s\n**Stardawn Version:** %s\n\n---\n\n### Latest Changes\n%s\n\n%s" "$LATEST_RELEASE" "$STARDAWN_VERSION" "$LATEST_RELEASE" "$STARDAWN_VERSION" "$COMMIT_TITLE" "$COMMIT_BODY")

          # --- RETRY LOOP 4: Create Release ---
          echo "Creating Release on GitHub (5 attempts)..."
          for i in {1..5}; do
            (
              # Subshell to retry the entire block
              gh release create "$LATEST_RELEASE" \
                --repo "$GITHUB_REPOSITORY" \
                --title "$RELEASE_TITLE" \
                --notes "$RELEASE_NOTES" \
                --latest
            ) && break
            
            echo "Release creation failed (Attempt $i). Waiting 20 seconds..."
            sleep 20
          done
